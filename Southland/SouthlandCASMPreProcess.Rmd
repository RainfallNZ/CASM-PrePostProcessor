---
title: "R Notebook to preprocess water quality data for use with CASM, for Horizons"
output: html_notebook
---

Some functions
```{r}
source("CASM_PrePostProcessorFunctions.R")

```

Set directories and data file names
```{r}
#Set the project directory
ProjectDirectory <- "D:\\Projects\\LWP\\SouthlandRegionalForumModelling"       #Tim Kerr's Windows Home laptop

#Set the data directory
DataDirectory     <- file.path(ProjectDirectory, "Data")

#Set the GIS directory
GISDataDirectory  <- file.path(DataDirectory,"GIS")

#REC data is available from the MfE data service. See https://data.mfe.govt.nz/layer/51826-river-environment-classification-manawatu-2010/ and https://data.mfe.govt.nz/layer/51847-river-environment-classification-watershed-manawatu-2010/

REC_rivers <- "SouthlandREC2"

REC_Catchments <- "ESWaterShedsWithPlanClasses" #An ESRI polygon shape file with Environment Southland Plan Classses

REC_MeanFlowFile <- file.path(DataDirectory,"REC2MeanFlow.RData")  #This is an RData file

#OutletReachNamesFile <- "OutletReachNames.csv"

WaterQualityStationFile <- "WaterQualitySites" #An ESRI Point shape file

LakeSiteFile <- "LakeSites"  #An ESRI Point shape file

EstuarySiteFile <- "Estuaries.csv"

ExtraCASMNodeSiteFile <- "ExtraCASMNodes"  #An ESRI Point Shape File

RiverOutletsFile <- "RiverMouthSites" #An ESRI Point Shape File

MajorCatchmentsFile <- "FactsheetZoneAreas"   #An ESRI polygon shapefile

GroundwaterZonesFile <- "Environment_Southland_Groundwater_Management_Zones_RWP_2010" #An ESRI polygon shapefile

PhysiographicDataFile <- "Environment_Southland_Physiographic_Zones" #An ESRI polygon shapefile

WaterPlanClassificationFile <- "WaterPlanClassification" #An ESRI Shape file

WaterPlanClassificationRasterFile <- "ES_PlanClassification.tif" #A raster file

```


load data
```{r}
#Load the major catchments
MajorCatchments <- readOGR(dsn =file.path(GISDataDirectory),
                           layer = MajorCatchmentsFile, stringsAsFactors = FALSE)
MajorCatchments <- spTransform(MajorCatchments,CRS("+init=epsg:2193") )
#Ditch Fiordland and Stewart Island
MajorCatchments <- MajorCatchments[-which(MajorCatchments$FactSheetZ %in% c("Fiordland","Stewart Island/ Rakiura Zone","Coastal Islands")),]
#Ditch the NA catchemnts
MajorCatchments <- MajorCatchments[!is.na(MajorCatchments$FactSheetZ),]

#Create a full domain (with help to clean it from https://stackoverflow.com/questions/12663263/dissolve-holes-in-polygon-in-r )
CompleteDomain <- gUnaryUnion(MajorCatchments)
outerRings = Filter(function(f){f@ringDir==1},CompleteDomain@polygons[[1]]@Polygons)
CompleteDomain = SpatialPolygons(list(Polygons(outerRings,ID=1)))
crs(CompleteDomain) <- crs(MajorCatchments)


#REC data has been sourced from LWP data stores. It has cut down versions of the attribute names, e.g. nzsegment is nzsgmnt. Keep an eye on this when comparing to other data sources that may have the full RECV2 attribute names.
RECReachNetwork <- readOGR(dsn =file.path(GISDataDirectory),
                           layer = REC_rivers)

RECReachNetwork <- spTransform(RECReachNetwork,CRS("+init=epsg:2193") )
#REstrict it to just the major catchments of interest
#RECReachNetwork <- gIntersection(RECReachNetwork,CompleteDomain,byid =TRUE)

#RECWatersheds <- readOGR(dsn = GISDataDirectory,
#                         layer = REC_Catchments)
#RECWatersheds <- spTransform(RECWatersheds,CRS("+init=epsg:2193") )

#Load the mean flow data for the REC V2. This is provided in an rdata file which contains the data frame REC2MeanFlow, with three columns, "nzsegment","QMean", and "us_catarea"
#load(REC_MeanFlowFile)

#Load the Southland water quality measurement site data
MeasurementSites <- readOGR(dsn =file.path(GISDataDirectory),
                           layer = WaterQualityStationFile, stringsAsFactors = FALSE)
MeasurementSites <- spTransform(MeasurementSites,CRS("+init=epsg:2193") )

#make sure the nzsegment attribute is numeric
MeasurementSites$nzsegment <- as.numeric(MeasurementSites$nzsegment)

#Load lake sites of interest
LakeSites <- readOGR(dsn =file.path(GISDataDirectory),
                           layer = LakeSiteFile, stringsAsFactors = FALSE)
LakeSites <- spTransform(LakeSites,CRS("+init=epsg:2193") )

#make sure the nzsegment attribute is numeric
LakeSites$nzsegment <- as.numeric(LakeSites$nzsegment)

#Load the additional subjective site locations
ExtraSites <- readOGR(dsn =file.path(GISDataDirectory,ExtraCASMNodeSiteFile),
                           layer = ExtraCASMNodeSiteFile, stringsAsFactors = FALSE)
ExtraSites <- spTransform(ExtraSites,CRS("+init=epsg:2193") )

#Load the additional river mouth site locations
RiverMouthSites <- readOGR(dsn =file.path(GISDataDirectory,RiverOutletsFile),
                           layer = RiverOutletsFile, stringsAsFactors = FALSE)
RiverMouthSites <- spTransform(RiverMouthSites,CRS("+init=epsg:2193") )

#Load the estuary site data
EstuarySites <- read.table(file.path(DataDirectory,EstuarySiteFile),header=TRUE,stringsAsFactors = FALSE, sep=",")
#Create a spatial file from it
EstuarySitesSpatial <- SpatialPointsDataFrame(coords = EstuarySites[,c("NZTME","NZTMN")],data = EstuarySites, proj4string = CRS("+init=epsg:2193"))



#Load the Physiographic Zones data
Physiography <- readOGR(dsn =file.path(GISDataDirectory,PhysiographicDataFile),
                           layer = PhysiographicDataFile)
Physiography <- spTransform(Physiography,CRS("+init=epsg:2193") )

#Convert to a raster with an attribute table, and  for mapping later on
  #Convert to raster, note the creation of a base raster in WGS84, which all subsequent raster's align to
  RasterBase <- raster(resolution = 250, ext = extent(MajorCatchments), crs = proj4string(MajorCatchments) )
  PhysiographyRaster <- rasterize(Physiography,RasterBase,"Physiograp")
  #Crop to the COmplete domain, and then mask to the same
  PhysiographyRaster <- crop(PhysiographyRaster,extent(CompleteDomain))
  PhysiographyRaster <- mask(PhysiographyRaster, CompleteDomain)
  
  PhysiographyRasterWGS84 <- projectRaster(PhysiographyRaster,crs = CRS("+init=epsg:4326"),method = "ngb")
  PhysiographyRasterWGS84 <- ratify(PhysiographyRasterWGS84)
  PhysiographyRAT <- levels(PhysiographyRasterWGS84)[[1]]
  PhysiographyRAT$Physiography <- levels(Physiography$Physiograp)
  levels(PhysiographyRasterWGS84)  <- PhysiographyRAT

  #Load the Environment Southland Water Plan Classification spatial data
#WaterPlanClassification <- readOGR(dsn = file.path(GISDataDirectory,WaterPlanClassificationFile), layer =WaterPlanClassificationFile, stringsAsFactors = FALSE)
#WaterPlanClassification <- spTransform(WaterPlanClassification,CRS("+init=epsg:2193") )
  
    
#Load the Water Plan classification raster data
  WaterPlanRaster <- raster(WaterPlanClassificationRasterFile)
  
  #reproject to WGS84 for mapping
  WaterPlanRasterWGS84 <- projectRaster(WaterPlanRaster,crs = CRS("+init=epsg:4326"),method = "ngb")
  WaterPlanRasterWGS84 <- ratify(WaterPlanRasterWGS84)
  WaterPlanClassRAT <- levels(WaterPlanRasterWGS84)[[1]]
  WaterPlanClassRAT$WaterPlanClass <- c("Hills", "Lakes", "Lowland Hardbed", "Lowland Softbed", "Mountain", "Natural State")
  levels(WaterPlanRasterWGS84)  <- WaterPlanClassRAT

#Load the Groundwater Management Zone data
GroundwaterZones <- readOGR(dsn =file.path(GISDataDirectory,GroundwaterZonesFile),
                           layer = GroundwaterZonesFile, stringsAsFactors = FALSE)
GroundwaterZones <- spTransform(GroundwaterZones,CRS("+init=epsg:2193") )


#Load the point source sites
#PointSourceSites <- read.csv(file.path(DataDirectory,"PointSourcesSummaryPC2_YE2012_04.csv"))

#Create a spatial points object set to NZTM
#PointSourceSitesSpatial <-SpatialPointsDataFrame(coords = PointSourceSites[,c("NZTM.X","NZTM.Y")],
#                                               data = PointSourceSites[,1:5],
#                                               proj4string = CRS("+init=epsg:2193"))


#Load the network outlet reach names lookup table. This has been manually prepared, and may need editing if the network changes to include outlet reaches not yet included in this file
#OutletReachNames <- read.csv(file.path(DataDirectory,OutletReachNamesFile), stringsAsFactors = FALSE)

```

Not sure if the following is needed anymore.
Get the "nzsegment" attributes of the lowest reach in each of the major catchments
```{r}
CatchmentReaches <- RECReachNetwork %over% MajorCatchments #Note this takes about a minute to do
RECReachNetwork$Catchment <- CatchmentReaches$FactSheetZ

#Work through each management zone to find the reach with the greatest distance to the headwater (the hdw_dst attribute). . I tried doing this based on the least largest area (the CUM_ARE attribute) but there were some zero values, I also tried distance to the sea (the LENGTHD attribute, but near the coast I was getting small reaches that were not the main river channel, but were closer to the sea)
MajorCatchmentOuteltReaches <- lapply(seq_along(MajorCatchments$FactSheetZ), function(SingleCatchment){
  #browser()
  CurrentCatchment <- MajorCatchments$FactSheetZ[SingleCatchment]
  CurrentCatchmentReaches <- RECReachNetwork[RECReachNetwork$Catchment == CurrentCatchment,]
  #OutletReach <- CurrentCatchmentReaches$nzsegment[which.max(CurrentCatchmentReaches$headw_dist)]
  OutletReach <- CurrentCatchmentReaches$nzsegment[which(CurrentCatchmentReaches$headw_dist > 30000 & CurrentCatchmentReaches$LENGTHDOWN < 500) ]
  return(data.frame(Catchment = rep(CurrentCatchment,length(OutletReach)),nzsegment = OutletReach))
})
#Convert the list into a dataframe
MajorCatchmentOuteltReachesDF <- do.call(rbind,MajorCatchmentOuteltReaches)
```


From the load sites, point source sites, and water management subzones outlets, create the required network
```{r}
#AllPoints <- c(MeasurementSites$nzsegment, PointSourceSites$nzsegment, MajorCatchmentOuteltReachesDF$nzsegment)
AllPoints <- c(MeasurementSites$nzsegment, LakeSites$nzsegment, EstuarySites$nzsegment, ExtraSites$nzsegment, OutletReaches = RiverMouthSites$nzsegment)
LoadNetwork <- lapply(AllPoints, function(x) {DownstreamReachFinder(RECNetwork = RECReachNetwork, SourceReach = x)} )
CompleteNetwork <- unlist(LoadNetwork)
CompleteNetwork <- CompleteNetwork[!duplicated(CompleteNetwork)]

CompleteSpatialNetwork <- RECReachNetwork[RECReachNetwork$nzsegment %in% CompleteNetwork,]
```

Then create a tributary table ready for CASM
```{r}

NetworkLabelList <- NetworkLabeler(CompleteSpatialNetwork)


#Add the tributary labels to the network
SegmentToLabelLookUpTable <- do.call(rbind,NetworkLabelList)
CompleteSpatialNetwork@data$Label <- SegmentToLabelLookUpTable$Label[match(CompleteSpatialNetwork@data$nzsgmnt,SegmentToLabelLookUpTable$nzsgmnt)]
#Add the prefixed labels to the network
SegmentToPrefixedLabelLookUpTable <- ReachLabeler(NetworkLabelList, OutletReachNames)
CompleteSpatialNetwork@data$PrefixedLabel <- SegmentToPrefixedLabelLookUpTable$Prefixedlabel[match(CompleteSpatialNetwork@data$nzsgmnt,SegmentToPrefixedLabelLookUpTable$nzsgmnt)]

#Add the 
#Save the network as a spatial file
writeOGR(CompleteSpatialNetwork, file.path(GISDataDirectory), "CASM-StreamNetwork", driver="ESRI Shapefile",overwrite_layer=TRUE)

TributaryConnectionTable <- TributaryConnectionCreator(RECNetwork = CompleteSpatialNetwork, TributaryLabelList = NetworkLabelList)
```

Then create a point source table ready for CASM,
a measurement site table ready for CASM,
and a diffuse inputs table ready for CASM
```{r}
#Create a dataframe of just the nzsegment number and the site name
PointSourceNodes <- PointSourceSites[,c("Site.Name","nzsegment")]

#Standardise the column names so that it matches the expected format in the CASMNodeTablePreparer() function
names(PointSourceNodes) <- c("NodeName","nzsgmnt")

#Prepare the CASM table with the bonus nzsgmnt column
PointSourceTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes = PointSourceNodes )

#rename the columns to match the CASM requirements
names(PointSourceTable) <- c("nzsgmnt","Point Source Name","Receiving Stream","Location (km)")
 
#Need to add the point source load to the table
PointSourceTable$"Annual Load (kg/yr)" <- round(PointSourceSites$TN.kgpy[match(PointSourceTable$nzsgmnt,PointSourceSites$nzsegment)],0)
```



#Repeat for the measurement sites
```{r}
MeasurementSiteNodes <- MeasurementSites[,c("sID","nzsegment")]
names(MeasurementSiteNodes) <- c("NodeName","nzsgmnt")
MeasurementSiteTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes= MeasurementSiteNodes)

#rename the columns to match the CASM conventions
names(MeasurementSiteTable) <- c("nzsgmnt","Site Name or No","Target Stream","Downstream Location (km)")

#Add the mean annual flow to the table
MeasurementSiteTable$"Mean flow (m3/s)" <- round(REC2MeanFlow$QMean[match(MeasurementSiteTable$nzsgmnt, REC2MeanFlow$nzsegment)],1)

#Add a variety of other fields from the Measurement Site data
MeasurementSiteTable$'Load (kg/yr)' <- round(MeasurementSites$load[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'Load Lci (kg/yr)' <- round(MeasurementSites$load_Lci[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'Load Uci (kg/yr)' <- round(MeasurementSites$load_Uci[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
```

#Repeat for diffuse inputs. This is a special case, because once the points have been found, they need to be joined with all the different landuse/LUC options
```{r}
#Start with all the diffuse source input nodes. These are the sub-management zone outlets
DiffuseInputsSiteNodes <- ManagementSubZoneOutletReachesDF
names(DiffuseInputsSiteNodes) <- c("NodeName","nzsgmnt")

#Build up the table of tributary names and locations associated with the diffuse source input sites
DiffuseInputsSiteTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes= DiffuseInputsSiteNodes)

#Now create a bigger version, with a row for each of the different landuse/LUC combinations within each sub-management zone
DiffuseInputsSiteExtendedTable <- SubZoneLanduseLUCSpatial@data

#Add the locations that we have just previously determined
DiffuseInputsSiteExtendedTable[,c("TribLocn","TribName")] <- DiffuseInputsSiteTable[match(SubZoneLanduseLUCSpatial@data$Zone_Code, DiffuseInputsSiteTable$CASMNodeName),c("TribLocn","TribName")]

#Add the leach rates
DiffuseLeachRateData <- DiffuseLoadTableCreator(ZoneLanduseLUCRaster = ,LeachRates = LeachRate)
DiffuseInputsSiteExtendedTable$"LeachRates"<- DiffuseLeachRateData$LeachRate[match(DiffuseInputsSiteExtendedTable$CombinedClassName,DiffuseLeachRateData$CombinedClassName)]

#Need to use raster-calculated area rather than polygon areas
DiffuseInputsSiteExtendedTable$`RasterBased Land Area (ha)` <- DiffuseLeachRateData$Hectares[match(DiffuseInputsSiteExtendedTable$CombinedClassName,DiffuseLeachRateData$CombinedClassName)]
#Remove all the surplus combined names. The raster version has much less.
DiffuseInputsSiteExtendedTable <- DiffuseInputsSiteExtendedTable[complete.cases(DiffuseInputsSiteExtendedTable),]

#I now need to adjust the locations of all the different landuse/LUC options for a single diffuse source point so that they are not all on exactly the same spot.
#Work along each sub management zone, get all the landuse/LUC classes, and increment the locations by 0.1 km
DiffuseInputsSiteExtendedTable$AdjustedTriblocn <- DiffuseInputsSiteExtendedTable$TribLocn
UniqueSubZones <- unique(DiffuseInputsSiteExtendedTable$Zone_Code)
for(SubZoneIndex in seq_along(UniqueSubZones)) {
  #get the subzone of interest
  SubZone <- UniqueSubZones[SubZoneIndex]
  
  #Get all the landuse/LUC classes in the subzone
  RowsOfInterest <- which(DiffuseInputsSiteExtendedTable$Zone_Code == SubZone)
  DiffuseInputsSiteExtendedTable$AdjustedTriblocn[RowsOfInterest] <- DiffuseInputsSiteExtendedTable$TribLocn[RowsOfInterest] + seq(0,by = 0.01, length.out = length(RowsOfInterest))
}

#rename the columns to match the CASM conventions
names(DiffuseInputsSiteExtendedTable) <- c("Landuse","LUC","Zone_Code","Polygon Land Area (ha)","Node Name","Original location (km)", "Receiving Stream","Export Coeff (kg/ha/yr)","Land Area (ha)","Discharge Location (km)")

```


An overview plot is required showing the various points and the underlying relevant spatial data.
This plot is pre-modelling to share with the project  participants so that they can check that the points are in the right place.
Chlopleth mapping is from here https://rstudio.github.io/leaflet/choropleths.html
Raster mapping is from here https://stackoverflow.com/questions/59110756/failed-to-add-a-categorical-legend-in-leaflet-in-r-using-addlegendlabels

Speed improvements were undertaken following https://stackoverflow.com/questions/44356224/leaflet-shiny-integration-slow
```{r}
library(rmapshaper)

RECForMaps <- RECReachNetwork[sqrt(RECReachNetwork@data$CUM_AREA)/10000 > 1,]
RECForMaps$LineWidthPixels <- as.integer(sqrt(RECForMaps@data$CUM_AREA)/10000)
RECForMaps <- RECForMaps[,"LineWidthPixels"]
RECForMaps <- ms_simplify(RECForMaps)

MajorCatchments <- ms_simplify(MajorCatchments)

#Reproject the vector spatial data to the maps projection ready for plotting
#Note that the raster data was reprojected when it was loaded.
#SpatialData <- list(MeasurementSites=MeasurementSitesSpatial, PointSourceSites=PointSourceSitesSpatial,
#                    SubZones=SubZonePolygons,RiverNetwork=CompleteSpatialNetwork)
SpatialData <- list(MeasurementSites=MeasurementSites,LakeSites=LakeSites,EstuarySites=EstuarySitesSpatial,ExtraSites=ExtraSites,RiverMouthSites=RiverMouthSites, RiverNetwork=RECForMaps,MajorCatchments=MajorCatchments,GroundwaterZones=GroundwaterZones)
MapData <- lapply(SpatialData, spTransform,CRS("+init=epsg:4326"))

MapData$Physiography <- PhysiographyRasterWGS84
MapData$WaterPlan <- WaterPlanRasterWGS84

MeasurementSiteLabels <- lapply(seq(nrow(MapData$MeasurementSites@data)), function(i) {
  paste0("Measurement site:", '</br>', 
          MapData$MeasurementSites@data[i, "sitename"]) 
})

EstuarySiteLabels <- lapply(seq(nrow(MapData$EstuarySites@data)), function(i) {
  paste0("Estuary site:", '</br>', 
          MapData$EstuarySites@data[i, "Name"]) 
})

LakeSiteLabels <- lapply(seq(nrow(MapData$LakeSites@data)), function(i) {
  paste0("Lake site:", '</br>', 
          MapData$LakeSites@data[i, "Lake_Name"]) 
})

ExtraSiteLabels <- lapply(seq(nrow(MapData$ExtraSites@data)), function(i) {
  paste0("Subcatchment site: ",  
          MapData$ExtraSites@data[i, "id"],'</br>',MapData$ExtraSites@data[i, "Reason"]) 
})

RiverMouthSiteLabels <- lapply(seq(nrow(MapData$RiverMouthSites@data)), function(i) {
  paste0("Rivermouth site: ",'</br>',MapData$RiverMouthSites@data[i, "River"]) 
})


#Setup the map
map <- leaflet::leaflet() %>% 
  leaflet::addProviderTiles(providers$OpenStreetMap) %>%
  setView(lng=168,lat=-46.0,zoom=9)

#Add the main catchments
Catchmentlabels <- sprintf(
  "<strong>Major Catchment</strong><br/>%s ",
  MapData$MajorCatchments@data$FactSheetZ
) %>% lapply(htmltools::HTML)

MCpal <- colorFactor("Dark2", domain = MapData$MajorCatchments@data$FactSheetZ)

map <- map %>%
  addPolygons(data=MapData$MajorCatchments,
  fillOpacity = 0,
  weight = 2,
  opacity = 1,
  color = "white",
  highlight = highlightOptions(
    weight = 5,
    color = "#666"),
  label = Catchmentlabels,
  group="Major Catchments")

#Add the groundwater zones
GroundwaterLabels <- sprintf(
  "<strong>Groundwater Zone</strong><br/>%s ",
  MapData$GroundwaterZones@data$Groundwate
) %>% lapply(htmltools::HTML)
GWpal <- colorFactor("YlOrRd", domain = MapData$GroundwaterZones@data$OBJECTID)

map <- map %>%
  addPolygons(data=MapData$GroundwaterZones,
  fillOpacity = 0,
  weight = 2,
  opacity = 1,
  color = "white",
  highlight = highlightOptions(
    weight = 5,
    color = "#666"),
  label = GroundwaterLabels,
  group="Groundwater Management Zones")

#Add the Physiography raster
Physpal <- colorFactor(rainbow(10), values(MapData$Physiography),
                    na.color = "transparent")
map <- map %>%
  addRasterImage(MapData$Physiography, colors = Physpal, opacity = 0.8, group = "Physiographic Zones") %>%  
  addLegend(pal = Physpal, 
            values = values(MapData$Physiography),
            title = "Physiography",
            labFormat  = labelFormat(
            transform = function(x) {
              levels(MapData$Physiography)[[1]]$Physiography[which(levels(MapData$Physiography)[[1]]$ID == x)]
            }),
            layerId = "Physiography",
            group="Physiographic Zones")

#Add the Water Plan Classification raster
WPpal <- colorFactor("Paired", values(MapData$WaterPlan),
                    na.color = "transparent")
map <- map %>%
  addRasterImage(MapData$WaterPlan, colors = WPpal, opacity = 0.8, group = "Water Plan Classes") %>%  
  addLegend(pal = WPpal, 
            values = values(MapData$WaterPlan),
            title = "Water Plan Classes",
            labFormat  = labelFormat(
            transform = function(x) {
              levels(MapData$WaterPlan)[[1]]$WaterPlanClass[which(levels(MapData$WaterPlan)[[1]]$ID == x)]
            }),
            layerId = "Water Plan Classess",
            group="Water Plan Classes")
  

map <- map %>%
  addCircleMarkers(data = MapData$MeasurementSites, color = "#FF3333",fillOpacity = 0.5, label = lapply(MeasurementSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$LakeSites, color = "darkorange", fillOpacity = 0.5, label = lapply(LakeSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$EstuarySites, color = "turquoise", fillOpacity = 0.5,label = lapply(EstuarySiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$RiverMouthSites, color = "brown", fillOpacity = 0.5,label = lapply(RiverMouthSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$ExtraSites, color = "#0066CC", fillOpacity = 0.5,label = lapply(ExtraSiteLabels, htmltools::HTML)) %>%
  
  addPolylines(data = MapData$RiverNetwork, color= "blue", weight = ~LineWidthPixels,group = "River Network") %>%
  
  addLegend("topright", colors = c("#FF3333","darkorange","turquoise","brown","lightblue"), labels = c("Measurement SItes","Lake Sites","Estuary Sites","River Mouth Sites","Subcatchment Sites"),
            title = "Sites",
            opacity = 1) %>%
  
  addLayersControl(
          overlayGroups =c("Major Catchments","Water Plan Classes","Physiographic Zones", "River Network", "Groundwater Management Zones"),
          options = layersControlOptions(collapsed=FALSE)
          ) %>%
  
  hideGroup(c("Major Catchments","Water Plan Classes","Groundwater Management Zones","River Network","Physiographic Zones"))

map

#save the mapdata as an R file so that it can be used in an RShinyApp
saveRDS(MapData,file.path(ProjectDirectory,"/ShinyApp/Data","SpatialData.RDS"))
```


The tributary connection table needs to be converted to an Excel Spreadsheet.


I need to create an excel table of CASM-Nodes, CASM-Reach-Names, CASM-Reach-Locations, CASM-Reach-Areas, CASM-Reach-Exp.Coeff
```{r}


Out <- createWorkbook()

addWorksheet(Out, "River Network")

writeData(Out, sheet = "River Network", x = TributaryConnectionTable[c("Tributary Name","Confluence Stream","Confluence Location (km)")])

addWorksheet(Out, "Point Source")

writeData(Out, sheet = "Point Source", x = PointSourceTable[,-1])

addWorksheet(Out, "Water Quality Stations")

writeData(Out, sheet = "Water Quality Stations", x = MeasurementSiteTable[,-1])

addWorksheet(Out, "Diffuse Inputs")


writeData(Out, sheet = "Diffuse Inputs", x = DiffuseInputsSiteExtendedTable[,c("Node Name","Receiving Stream","Discharge Location (km)","Land Area (ha)","Export Coeff (kg/ha/yr)")])

saveWorkbook(Out, file.path(DataDirectory,"CASM-Inputs.xlsx"), overwrite = T)
```
 By way of a check, it will be helpful to compare the total sub-management zone loads from the gridded leachrate data with the total sub-management zone loads from the zone/landuse/LUC data.
 Start with the leach rate raster data, and get the average leachrate for each zone and multiply by the area.
 Note that  I need to use the subzones from the SubZone
 
 Then, as a check, get the load for each zone-landuse-LUC combination, and sum in each zone.
 It would also be good to add a check of total load in catchments upstream of a water quality network being more than the total load measured. If they were less, then the attenuation would have to be greater than 1!
```{r}
#Note that to ensure I am comparing apples with apples, I am using the SubZoneLandUseLUCSpatial data to find the SubZone areas (rather than using the pre-prepared cleaned sub zone spatial data which has been "cleaned" so is slightly different in area!!)
test <- unionSpatialPolygons(SubZoneLanduseLUCSpatial,IDs = SubZoneLanduseLUCSpatial@data$Zone_Code )
testid <- sapply(slot(test, "polygons"), function(x) slot(x, "ID"))
test2 <- SpatialPolygonsDataFrame(test,data.frame(Zone_Code = testid,row.names = testid))

Zoneleachrates <- raster::extract(LeachRate, test2, fun = mean, na.rm=TRUE, sp=TRUE, weights = TRUE)
Zoneleachrates$area <- raster::area(Zoneleachrates)
Zoneleachrates$loads <- with(Zoneleachrates@data,layer * area / 10000)

DiffuseInputsSiteExtendedTable$load <- DiffuseInputsSiteExtendedTable$`Export Coeff (kg/ha/yr)` * DiffuseInputsSiteExtendedTable$`Land Area (ha)`
library(plyr)
bob <- ddply(DiffuseInputsSiteExtendedTable, "Zone_Code", function(x) sum(x$load, na.rm=TRUE))

ddply(DiffuseInputsSiteExtendedTable, "Zone_Code", function(x) sum(x$'Land Area (ha)', na.rm=TRUE))

#Ideally the loads from the raster and the DiffuseinputsSiteExtendedTable would be the same, but they are not!!
#But they are close for most water management sub-zones
charlie <- cbind(Zoneleachrates@data,bob)
charlie$load_diff <- charlie$loads - charlie$V1
charlie$load_diff_percent <- round(charlie$load_diff / charlie$loads * 100,0)
print(charlie)
```
 

```{r}
# NOT RUN {
# !formatR
library(leaflet)
# a manual legend
leaflet() %>% addTiles() %>% addLegend(
  position = "bottomright",
  colors = rgb(t(col2rgb(palette())) / 255),
  labels = palette(), opacity = 1,
  title = "An Obvious Legend"
)

# }
# NOT RUN {
# an automatic legend derived from the color palette
df <- local({
  n <- 300; x <- rnorm(n); y <- rnorm(n)
  z <- sqrt(x ^ 2 + y ^ 2); z[sample(n, 10)] <- NA
  data.frame(x, y, z)
})
pal <- colorNumeric("OrRd", df$z)
leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, group = "circles", position = "bottomleft") %>%
  addLayersControl(overlayGroups = c("circles"))

# format legend labels
df <- data.frame(x = rnorm(100), y = rexp(100, 2), z = runif(100))
pal <- colorBin("PuOr", df$z, bins = c(0, .1, .4, .9, 1))
leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, group = "circles", position = "bottomleft") %>%
  addLayersControl(overlayGroups = c("circles"))

leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, labFormat = labelFormat(
    prefix = "(", suffix = ")%", between = ", ",
    transform = function(x) 100 * x
  ),  group = "circles", position = "bottomleft" ) %>%
  addLayersControl(overlayGroups = c("circles"))
# }
```

